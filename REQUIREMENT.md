# ポケモンバトルシステム設計概要

本ドキュメントは、Nest.js、クリーンアーキテクチャ、および Prisma を使用して、スケーラブルなポケモンバトル環境を構築するためのシステム設計をまとめたものである。

## 1. 基本設計思想：データとロジックの分離

本システムの設計における最も重要な原則は、「データ（状態）」と「ロジック（振る舞い）」を厳密に分離することである。

- **データベース (DB) の役割**
  - 例: 「カイリューの特性は『マルチスケイル』である」という状態を永続化する。
  - ロジックそのもの（例: 「HP が満タンならダメージ半減」）は DB に保存しない。

- **アプリケーション (バトルエンジン) の役割**
  - DB から取得した「マルチスケイル」という名前（識別子）に基づき、ハードコードされたロジックを実行する。

## 2. 複雑なロジック（特性・技）の管理

特に「特性」のように複雑で将来的に拡張されうる（例: 1000 種類を超える）ロジックは、以下の設計アプローチを採用する。

### 2.1. マスターデータの役割 (Prisma / DB)

Ability や Move のマスターテーブルは、ロジックの「補助」に徹する。

- **name (String)**: アプリケーション側がロジックを識別するための一意なキー（例: `Intimidate`, `Levitate`）。
- **description (String)**: UI 表示用の説明文。
- **triggerEvent (String / Enum)**: ロジックの発動タイミングを示す補助フラグ（例: `OnEntry`, `OnTakingDamage`, `Passive`）。
- **effectCategory (String / Enum)**: 効果の大まかな分類（例: `StatChange`, `Immunity`, `Weather`）。

### 2.2. アプリケーション（バトルエンジン）のアーキテクチャ

switch 文による巨大な分岐処理は、保守性・拡張性の観点から採用しない。代わりに Strategy パターンとレジストリ（Registry）パターンを採用する。

- **インターフェース定義**: 特性ロジックの共通規格（例: `IAbilityEffect`）を定義する。これには `onEntry()`, `modifyDamage()`, `onTurnEnd()` といった、様々な発動タイミングに対応するメソッドシグネチャが含まれる。
- **ロジックの実装**: 特性ごとに、インターフェースを実装した個別のクラス（または関数）を作成する（例: `IntimidateEffect.ts`, `LevitateEffect.ts`）。
- **レジストリ（登録簿）**: DB の name（文字列キー）と、上記で実装したロジッククラスを紐付ける Map を作成する（例: `Map<string, IAbilityEffect>`）。
  - 例: `abilityRegistry.set('いかく', new IntimidateEffect())`
- **バトルエンジンの実行**: `triggerEvent` に基づいて処理を行う。巨大な switch 文の代わりに、DB から取得した特性の `name` をキーとしてレジストリを呼び出し、該当するロジックを実行する。

バトルエンジンの擬似コード（`onEntry` イベント）:

```ts
const abilityName = pokemon.ability.name; // DB から取得した名前
const event = pokemon.ability.triggerEvent; // DB から取得したトリガー

if (event === 'OnEntry') {
  // switch 文ではなく、Map からロジックを取得
  const effectLogic = abilityRegistry.get(abilityName);
  if (effectLogic) {
    effectLogic.onEntry(pokemon, battleContext);
  }
}
```

## 3. 技術スタックとアーキテクチャ

- **フレームワーク**: Nest.js
- **アーキテクチャ**: クリーンアーキテクチャ
- **ORM**: Prisma
- **リアルタイム通信**: WebSocket (Nest.js Gateway)

### 3.1. クリーンアーキテクチャのレイヤー構造

依存性のルール（内側は外側を知らない）を厳守する。

- **ドメイン (Entities)**
  - システムの中核。Nest.js や Prisma に依存しない純粋な TypeScript クラス。
  - 例: `Pokemon`, `Battle`, `BattlePokemonStatus` といったエンティティ、`DamageCalculator` などのドメインロジック。
  - `*.repository.interface.ts`（抽象リポジトリ）もここに定義する。

- **アプリケーション (Use Cases)**
  - ビジネスロジック。ドメイン層をオーケストレーション（指揮）する。
  - 例: `ExecuteTurnUseCase`（ターン処理）, `StartBattleUseCase`（バトル開始）。

- **インフラストラクチャ (Interface Adapters)**
  - 外界とアプリケーション層を接続する。
  - `*.controller.ts`: HTTP リクエストを処理し、ユースケースを呼び出す。
  - `*.gateway.ts`: WebSocket 通信を処理し、ユースケースを呼び出す。
  - `*.prisma.repository.ts`: ドメイン層で定義された `*.repository.interface.ts` の具象実装。Prisma Client をここで使用する。

- **フレームワーク (Frameworks & Drivers)**
  - Nest.js 自体、Prisma Client、PostgreSQL など。

### 3.2. ディレクトリ構造（抜粋）

`src/modules` 配下に、機能ドメインごとにモジュールを分割する。

```text
src/
├── modules/
│   ├── battle/           # バトル進行モジュール
│   │   ├── domain/
│   │   │   ├── entities/
│   │   │   ├── logic/      # DamageCalculator, AbilityRegistry など
│   │   │   └── battle.repository.interface.ts
│   │   ├── application/
│   │   │   └── use-cases/  # ExecuteTurnUseCase など
│   │   ├── infrastructure/
│   │   │   ├── persistence/  # battle.prisma.repository.ts
│   │   │   ├── battle.controller.ts
│   │   │   └── battle.gateway.ts
│   │   └── battle.module.ts
│   │
│   ├── pokemon/          # ポケモンマスターデータ管理モジュール
│   │   ├── domain/
│   │   │   ├── entities/   # Pokemon, Move, Ability
│   │   │   └── pokemon.repository.interface.ts
│   │   ├── application/
│   │   ├── infrastructure/
│   │   └── pokemon.module.ts
│   │
│   └── trainer/          # ユーザー・育成個体管理モジュール
│       ├── domain/
│       ├── application/
│       ├── infrastructure/
│       └── trainer.module.ts
│
└── shared/               # 共有リソース（PrismaModule など）
```

## 4. Prisma スキーマ設計のハイライト

`prisma/schema.prisma` は、以下の 3 つの主要カテゴリで構成される。

- **静的マスターデータ**
  - `Pokemon`, `Type`, `Move`, `Ability`, `Item`, `Nature`, `TypeEffectiveness`
  - これらはゲームのバージョンによって定義される不変のデータ。

- **ユーザーデータ（動的データ）**
  - `Trainer`: ユーザーアカウント。
  - `TrainedPokemon`: ユーザーが育成した個体（個体値、努力値、技構成など）。
  - `Team`: `TrainedPokemon` で構成されるバトルチーム。

- **バトルデータ（揮発性データ）**
  - `Battle`: バトル全体の状態（天候、ターン数、フィールド状態）。
  - `BattlePokemonStatus`: 最も重要。バトル中のポケモン個別の状態（現在の HP、状態異常、ランク補正）を管理する。`Battle` と `TrainedPokemon` に関連付けられる。

## 5. バトルルールの詳細仕様

本システムで実装されているバトルルールの詳細仕様を以下に記載する。

### 5.1. バトル基本ルール

- **ターン制**: 各トレーナーが行動を選択し、同時に実行される
- **行動順の決定**: 速度と優先度を考慮して決定
  - 優先度が高い技を先に実行
  - 優先度が同じ場合は、速度が高いポケモンが先に行動
  - 速度ランク補正を考慮
- **標準レベル**: レベル50を標準とする（ダメージ計算などで使用）

### 5.2. ダメージ計算の詳細

ダメージ計算は `DamageCalculator` クラスで実装されている。

#### 基本計算式

``` markdown
ダメージ = floor((floor((2 * level / 5 + 2) * power * A / D) / 50) + 2) * その他の補正
```

- `level`: ポケモンのレベル（標準: 50）
- `power`: 技の威力
- `A`: 攻撃側の実効ステータス（ランク補正適用後）
- `D`: 防御側の実効ステータス（ランク補正適用後）

#### 補正要素

1. **タイプ一致（STAB: Same Type Attack Bonus）**
   - 技のタイプとポケモンのタイプ（プライマリまたはセカンダリ）が一致する場合、1.5倍
   - 一致しない場合は1.0倍

2. **タイプ相性**
   - 効果値: 0（効果なし）、0.5（いまひとつ）、1.0（普通）、2.0（効果抜群）
   - 複数タイプのポケモンの場合、各タイプとの相性を掛け算
   - 例: ほのおタイプの技 → くさ・むしタイプのポケモン = 2.0 × 2.0 = 4.0倍

3. **ランク補正**
   - ランク範囲: -6から+6まで
   - 正のランク: 倍率 = (3 + rank) / 3
   - 負のランク: 倍率 = 3 / (3 - rank)
   - 例: ランク+1 = 4/3倍、ランク-1 = 3/4倍

4. **状態異常補正**
   - やけど（Burn）: 物理攻撃の威力が0.5倍
   - その他の状態異常はダメージ計算に直接影響しない（ターン終了時のダメージは別処理）

5. **天候補正**
   - 晴れ（Sun）:
     - ほのおタイプの技: 1.5倍
     - みずタイプの技: 0.5倍
   - 雨（Rain）:
     - みずタイプの技: 1.5倍
     - ほのおタイプの技: 0.5倍
   - 砂嵐（Sandstorm）・あられ（Hail）: 補正なし（1.0倍）

6. **特性効果による補正**
   - 攻撃側の特性: `modifyDamageDealt()` メソッドでダメージを修正
   - 防御側の特性: `modifyDamage()` メソッドで受けるダメージを修正
   - 例: マルチスケイル（HP満タン時、受けるダメージ半減）

### 5.3. 状態異常の仕様

状態異常の処理は `StatusConditionHandler` クラスで実装されている。

#### やけど（Burn）

- **物理攻撃補正**: 物理攻撃の威力が0.5倍
- **ターン終了時のダメージ**: 最大HPの1/16
- **交代時の解除**: 解除される

#### こおり（Freeze）

- **行動不能**: 行動不能になる
- **解除確率**: 各ターン開始時に20%の確率で解除
- **交代時の解除**: 解除される

#### どく（Poison）

- **ターン終了時のダメージ**: 最大HPの1/8
- **交代時の解除**: 解除される

#### もうどく（BadPoison）

- **ターン終了時のダメージ**: 最大HPの1/16から始まり、毎ターン増加（最大1/2）
  - ターン数に応じて: 1/16, 2/16, 3/16, ..., 8/16 (1/2)
- **交代時の解除**: 解除される

#### ねむり（Sleep）

- **行動不能**: 行動不能になる
- **自動解除**: 1-3ターン後に自動解除
  - 1ターン目: 33%の確率で解除
  - 2ターン目: 50%の確率で解除
  - 3ターン目以降: 100%の確率で解除
- **交代時の解除**: 解除される

#### まひ（Paralysis）

- **素早さ補正**: 素早さが0.5倍（速度ランク補正とは別）
- **行動不能確率**: 25%の確率で行動不能
- **交代時の解除**: 解除される

### 5.4. 命中率計算の仕様

命中率判定は `AccuracyCalculator` クラスで実装されている。

#### 基本命中率

- 技の基本命中率: 0-100（必中技の場合はnull）
- 必中技（accuracy === null）の場合は常に命中

#### ランク補正

- 命中ランク補正: 攻撃側の `accuracyRank` に基づく倍率
- 回避ランク補正: 防御側の `evasionRank` に基づく倍率
- 実効命中率 = 基本命中率 × (命中ランク倍率 / 回避ランク倍率)
- ランク補正の計算式はダメージ計算と同じ（正のランク: (3 + rank) / 3、負のランク: 3 / (3 - rank)）

#### 特性による補正

- 攻撃側の特性: `modifyAccuracy()` メソッドで命中率を修正
- 防御側の特性: `modifyEvasion()` メソッドで回避率を修正（0.0-1.0の値、大きいほど回避率が高い）

#### 最終判定

- 実効命中率を0-100の範囲に制限
- ランダムな値（0-100）を生成し、実効命中率未満なら命中

### 5.5. 特性・技の効果の仕様

#### 特性レジストリパターン

特性のロジックは `AbilityRegistry` クラスで管理される。

- **登録方法**: DBの `name` フィールドをキーとして、`IAbilityEffect` インターフェースを実装したクラスを登録
- **発動タイミング**: `triggerEvent` に基づいて処理
  - `OnEntry`: 場に出すとき
  - `OnTakingDamage`: ダメージを受けるとき
  - `OnDealingDamage`: ダメージを与えるとき
  - `OnTurnEnd`: ターン終了時
  - `OnSwitchOut`: 場から下がるとき
  - `Passive`: 常時発動（無効化されない限り）
  - `OnStatusCondition`: 状態異常になったとき
  - `Other`: その他

- **主要メソッド**:
  - `onEntry()`: 場に出たときの処理
  - `modifyDamage()`: 受けるダメージを修正
  - `modifyDamageDealt()`: 与えるダメージを修正
  - `modifyAccuracy()`: 命中率を修正
  - `modifyEvasion()`: 回避率を修正
  - `onTurnEnd()`: ターン終了時の処理

#### 技レジストリパターン

技の特殊効果ロジックは `MoveRegistry` クラスで管理される。

- **登録方法**: DBの `name` フィールドをキーとして、`IMoveEffect` インターフェースを実装したクラスを登録
- **主要メソッド**:
  - `onHit()`: 技が命中したときの処理（状態異常付与など）
  - `onUse()`: 技を使用したときの処理

- **注意**: 技の基本情報（威力、命中率、PPなど）はDBに保存されるが、特殊効果（例: 「10%の確率でやけどを付与する」）はアプリケーション側で管理

## 6. データ取得とアプリケーション層の依存関係

本システムでは、クリーンアーキテクチャの原則に従い、データ取得とアプリケーション層の依存関係を明確に分離している。

### 6.1. リポジトリパターンの実装

#### Domain層でのインターフェース定義

Domain層（`domain/*.repository.interface.ts`）で、データアクセスのインターフェースを定義する。

- 例: `IPokemonRepository`, `IAbilityRepository`, `IMoveRepository`, `IBattleRepository`
- これらのインターフェースは、Nest.jsやPrismaに依存しない純粋なTypeScriptインターフェース

#### Infrastructure層でのPrisma実装

Infrastructure層（`infrastructure/persistence/*.prisma.repository.ts`）で、上記インターフェースの具象実装を提供する。

- Prisma Clientを使用してDBからデータを取得
- Domain層のエンティティに変換して返す
- 依存性逆転の原則により、Domain層はInfrastructure層の実装を知らない

#### 依存性注入の設定

Nest.jsのモジュール（`*.module.ts`）で、インターフェースと具象実装をバインドする。

```typescript
{
  provide: POKEMON_REPOSITORY_TOKEN,
  useClass: PokemonPrismaRepository,
}
```

### 6.2. データフローの説明

#### 典型的なデータ取得フロー

1. **ユースケース層の呼び出し**
   - `ExecuteTurnUseCase` などのユースケースが、リポジトリインターフェースを呼び出す
   - 例: `await this.pokemonRepository.findById(id)`

2. **Infrastructure層でのデータ取得**
   - Prisma実装がDBからデータを取得
   - PrismaのデータモデルをDomain層のエンティティに変換

3. **Domain層でのロジック実行**
   - エンティティを取得後、ドメインロジック（`DamageCalculator`, `StatusConditionHandler`など）を実行

#### 特性・技ロジックの取得フロー

1. **DBから特性名を取得**
   - `TrainedPokemon` から `ability.name` を取得（例: "いかく"）

2. **レジストリからロジッククラスを取得**
   - `AbilityRegistry.get(abilityName)` でロジッククラスを取得
   - 例: `IntimidateEffect` インスタンス

3. **ロジックを実行**
   - 適切なメソッド（`onEntry()`, `modifyDamage()`など）を呼び出し
   - バトルコンテキスト（天候、フィールド状態など）を渡す

#### データ変換の責務

- **Prisma → Domain**: Infrastructure層の責務
  - Prismaのデータモデル（`Prisma.PokemonGetPayload<...>`）をDomain層のエンティティ（`Pokemon`）に変換
  - 例: `toDomainEntity()` メソッド

- **Domain → Prisma**: Infrastructure層の責務
  - Domain層のエンティティをPrismaのデータモデルに変換して保存
  - 例: `toPrismaInput()` メソッド

### 6.3. 依存関係の方向性

#### 依存性逆転の原則

- **Domain層**: 外部に依存しない（Nest.js、Prisma、PostgreSQLに依存しない）
- **Application層**: Domain層に依存（リポジトリインターフェースを使用）
- **Infrastructure層**: Domain層とApplication層に依存（インターフェースを実装）

#### レジストリパターンとの連携

- **レジストリの初期化**: モジュールのコンストラクタで実行
  - 例: `PokemonModule` のコンストラクタで `AbilityRegistry.initialize()` を呼び出し

- **レジストリへのアクセス**: Domain層のロジックから直接アクセス
  - 例: `DamageCalculator` から `AbilityRegistry.get()` を呼び出し

## 7. PokeAPIを使ったシードデータ作成の方針

本システムでは、マスターデータの初期投入のために、PokeAPIを利用したシードデータ作成を計画している。

### 7.1. シードデータの目的

- **マスターデータの初期投入**: Pokemon、Move、Ability、Type、TypeEffectivenessなどのマスターデータをDBに投入
- **開発・テスト環境での動作確認**: 開発やテスト時に、実際のポケモンデータを使用して動作確認を行う

### 7.2. PokeAPIの利用方針

#### API仕様

- **APIバージョン**: PokeAPI v2
- **APIドキュメント**: <https://pokeapi.co/docs/v2>
- **認証**: 不要（公開API）
- **レート制限**: 公式にはレート制限なし（ただし、ローカルキャッシュを推奨）

#### 取得するデータ

1. **Pokemon**
   - 図鑑番号（nationalDex）
   - 名前（name, nameEn）
   - タイプ（primaryType, secondaryType）
   - 基本ステータス（baseHp, baseAttack, baseDefense, baseSpecialAttack, baseSpecialDefense, baseSpeed）

2. **Move**
   - 名前（name, nameEn）
   - タイプ（typeId）
   - カテゴリ（category: Physical, Special, Status）
   - 威力（power）
   - 命中率（accuracy）
   - PP（pp）
   - 優先度（priority）
   - 説明（description）

3. **Ability**
   - 名前（name, nameEn）
   - 説明（description）
   - 発動タイミング（triggerEvent）
   - 効果カテゴリ（effectCategory）

4. **Type**
   - 名前（name, nameEn）

5. **TypeEffectiveness**
   - タイプ相性マトリクス（typeFromId, typeToId, effectiveness）

### 7.3. シードスクリプトの実装方針

#### ファイル構成

- **シードスクリプト**: `prisma/seed.ts` を作成
- **PokeAPIクライアント**: PokeAPIからデータを取得するためのユーティリティ関数

#### 実装の考慮事項

1. **エラーハンドリング**
   - APIリクエストの失敗時のリトライロジック
   - ネットワークエラーやタイムアウトの処理

2. **既存データのチェック**
   - 重複データの回避（`findUnique` などで既存データをチェック）
   - 既存データがある場合はスキップまたは更新

3. **データの整合性**
   - 外部キー制約の考慮（Type → Pokemon, Move, TypeEffectiveness）
   - トランザクション処理の実装

4. **パフォーマンス**
   - バッチ処理による効率的なデータ投入
   - 並列処理の検討（ただし、APIの負荷を考慮）

### 7.4. データマッピングの考慮事項

#### 名前の対応

- **PokeAPIのデータ**: 主に英語名（nameEn）が提供される
- **日本語名の取得**: PokeAPIの `names` フィールドから日本語名を取得
- **レジストリとの一致**: 特性・技の `name` フィールドとレジストリのキーを一致させる必要がある
  - 例: AbilityRegistryに `'いかく'` が登録されている場合、DBの `name` も `'いかく'` にする

#### タイプ相性データの変換

- **PokeAPIの形式**: `damage_relations` フィールドからタイプ相性を取得
- **DBの形式**: `TypeEffectiveness` テーブルに `typeFromId`, `typeToId`, `effectiveness` として保存
- **効果値の変換**:
  - `no_damage_to` → effectiveness = 0
  - `half_damage_to` → effectiveness = 0.5
  - `double_damage_to` → effectiveness = 2.0
  - その他 → effectiveness = 1.0

#### 特性・技のメタデータ

- **triggerEvent**: PokeAPIから直接取得できない場合、特性名に基づいてマッピングテーブルを作成
- **effectCategory**: 同様に、特性名に基づいてマッピングテーブルを作成

### 7.5. 実装の優先順位

1. **Phase 1**: Type、Pokemon、Moveの基本データ投入
2. **Phase 2**: Ability、TypeEffectivenessのデータ投入
3. **Phase 3**: PokemonAbility、PokemonMoveの中間テーブルのデータ投入

### 7.6. 注意事項

- **PokeAPIのレート制限**: 公式にはレート制限なしとされているが、過度なリクエストは避ける
- **ローカルキャッシュ**: 取得したデータをローカルにキャッシュし、再実行時の高速化を図る
- **データの更新**: PokeAPIのデータが更新された場合の再投入方法を検討
- **エッジケース**: 一部のポケモンや技でデータが不完全な場合の処理

## 8. 開発プロセスと品質保証

セーフティネットとして、以下の開発ルールを設ける

### 8.1. ブランチ管理

- **mainブランチへの直接コミットは禁止**
  - 機能追加・修正・リファクタリングを行う場合は、必ず適切な名前のブランチを作成してから作業を開始
  - コミット前に現在のブランチを確認し、mainブランチの場合はブランチを作成してからコミット
  - ブランチ命名規則: `feat/`, `fix/`, `refactor/`, `chore/`, `docs/` のプレフィックスを使用
  - mainブランチへのマージは、必ずプルリクエストを作成してレビューを受けること

### 8.2. テストと動作確認

- **新規ロジックを追加した場合は、必ずテストケースを追加するか、動作確認を行うこと**
  - ドメインロジック（計算ロジック、バリデーションなど）はテストケースを追加し、テストを実行して成功することを確認
  - インフラストラクチャ層（API、WebSocketなど）は実際にアプリを起動して動作確認を行う
  - テストケースを追加した場合は、必ずテストを実行して成功することを確認してからコミット

### 8.3. コミット前チェック項目

コミット前に、以下の項目を**必ず**確認する。

- 現在のブランチがmainでないことを確認
- `npm run lint` がエラーなく通過すること
- `npm run build` が成功すること
- 新規ロジックを追加した場合、最低限のテストまたは動作確認を行ったこと
- Prismaスキーマを変更した場合、マイグレーションが必要な場合は準備したこと

### 8.4. コミットメッセージ規約

すべてのコミットメッセージは、Conventional Commits 形式に従う。

- `feat`: 新機能
- `fix`: バグ修正
- `refactor`: リファクタリング
- `docs`: ドキュメントのみの変更
- `test`: テストの追加・変更
- `chore`: ビルドプロセスやツールの変更
- `style`: コードの動作に影響しない変更（フォーマット、空白など）

### 8.5. セルフレビューの観点

コミット前に、以下の観点からコードをセルフレビューすることを必須とする。

#### マジックナンバー

確率値、ダメージ計算の係数、ステータス計算の係数、倍率、レベルやターン数の上限、最小値・最大値の制約など、意味が不明確な数値が直接記述されていないか確認する。

対応: クラスレベルの `private static readonly` 定数として定義し、意味が明確な名前を付ける。

#### エラーハンドリング

null/undefinedチェックが適切に行われているか、例外処理が適切か、エラーメッセージが明確か、エラーが適切に伝播されているかを確認する。

対応: null/undefinedチェックを追加し、適切な例外をthrowし、エラーメッセージを明確にする。

#### バリデーション

パラメータのバリデーションが適切か、境界値チェックが実装されているか、不正な値に対する処理が適切かを確認する。

対応: 入力値のバリデーションを追加し、境界値チェックを実装する。

#### パフォーマンス

不要なループや再帰がないか、適切なデータ構造を使用しているか、メモリリークの可能性がないか、不要なデータベースクエリがないかを確認する。

対応: アルゴリズムを最適化し、適切なデータ構造を選択し、メモリ管理を改善する。

#### メモリ管理

MapやSetなどのコレクションが適切にクリーンアップされているか、イベントリスナーの解除漏れがないか、タイマーやインターバルのクリーンアップが適切かを確認する。

対応: 不要になったリソースを適切に解放し、ライフサイクルに応じたクリーンアップ処理を追加する。

#### 型安全性

`any`型を使用していないか、型アサーションを過度に使用していないか、型定義が適切かを確認する。

対応: `any`型を避け、適切な型を定義し、型アサーションを最小限にする。

#### 重複コード

同じロジックが複数箇所に存在しないか、類似した処理が重複していないかを確認する。

対応: 共通処理を関数やメソッドに抽出し、ユーティリティクラスを作成する。

#### 関数・メソッドの責務

関数が複数の責務を持っていないか、関数が長すぎないか（100行以上など）、複雑度が高くないかを確認する。

対応: 関数を小さな単位に分割し、責務を明確に分離する。

#### 可読性

変数名が明確か、ネストが深すぎないか、条件式が複雑すぎないかを確認する。

対応: 意味が明確な変数名・関数名を使用し、ネストを浅くし、条件式を簡潔にする。

#### ロジックの正確性

計算式が正しいか、条件分岐が適切か、エッジケースを考慮しているかを確認する。

対応: ロジックを再確認し、エッジケースを考慮し、テストケースで検証する。

#### コメント

変数名やメソッド名だけでは意図が伝わらない箇所にコメントがあるか、複雑な計算式やロジックの説明が適切か、データ構造のキーの意味が明確かを確認する。

対応: コメントで意図を明確に説明し、データ構造のキーの意味を明記する。

#### コードスタイル

フォーマットが統一されているか、命名規則が統一されているか、インポート順序が統一されているかを確認する。

対応: ESLint/Prettierの設定に従い、既存のコードスタイルに合わせる。

#### 設計思想の遵守

クリーンアーキテクチャの原則に反していないか、データとロジックの分離原則に反していないか、依存性の方向が適切かを確認する。

対応: REQUIREMENT.mdの設計思想を確認し、必要に応じて設計を修正する。

#### テスト

ドメインロジックにテストケースがあるか、エッジケースがテストされているか、テストカバレッジが適切かを確認する。

対応: テストケースを追加し、テストを実行して成功することを確認する。

#### セキュリティ

SQLインジェクションの可能性がないか、XSSの可能性がないか、認証・認可が適切に実装されているかを確認する。

対応: セキュリティベストプラクティスに従い、適切なサニタイゼーションを実装する。

#### 並行処理

レースコンディションの可能性がないか、デッドロックの可能性がないか、スレッドセーフティが確保されているかを確認する。

対応: 適切な同期機構を使用し、レースコンディションを回避する。

## 9. 開発効率化

特性・技の特殊効果実装は、大量の類似コードを生成する必要があるため、開発効率を向上させるためのツールとパターンを整備する。

### 9.1. コード生成ツール（特性・技）

基底クラスを活用した実装が多いため、設定ファイルからコードを自動生成するツールを導入する。

#### 目的

- **実装時間の短縮**: 特性・技の実装時間を10分→1分に短縮
- **タイポ・設定ミスの削減**: 自動生成により人的ミスを削減
- **一貫性の確保**: コードスタイルと構造の統一

#### 実装方針

設定ファイルベースの実装

特性・技の効果クラスを設定ファイルから自動生成する。

```json
// config/abilities.json
{
  "ちくでん": {
    "baseClass": "BaseTypeAbsorbEffect",
    "params": {
      "immuneTypes": ["でんき"],
      "healRatio": 0.25
    }
  },
  "すいすい": {
    "baseClass": "BaseWeatherDependentSpeedEffect",
    "params": {
      "requiredWeathers": ["Rain"],
      "speedMultiplier": 2.0
    }
  }
}
```

生成スクリプト

```typescript
// scripts/generate-ability-effect.ts
// 設定ファイルから特性効果クラスを自動生成
// - クラスファイルの生成
// - レジストリへの登録コードの生成
```

生成されるコード例

```typescript
// 自動生成されるコード
import { BaseTypeAbsorbEffect } from '../base/base-type-absorb-effect';

/**
 * ちくでん（Volt Absorb）特性の効果
 * でんきタイプの技を無効化し、最大HPの1/4回復
 */
export class VoltAbsorbEffect extends BaseTypeAbsorbEffect {
  protected readonly immuneTypes = ['でんき'] as const;
  protected readonly healRatio = 0.25;
}
```

#### 対応する基底クラス

以下の基底クラスに対応する設定ファイル形式を定義する。

- `BaseTypeAbsorbEffect`: タイプ吸収系
- `BaseWeatherDependentSpeedEffect`: 天候依存速度系
- `BaseStatusConditionEffect`: 状態異常付与系（技用）
- `BaseTypeImmunityEffect`: タイプ無効化系
- `BaseOpponentStatChangeEffect`: 相手ステータス変化系
- `BaseConditionalDamageEffect`: 条件付きダメージ修正系

### 9.2. テストテンプレート生成

既存のテストパターンから、基底クラスごとのテストテンプレートを自動生成する。

#### 目的

- **テスト作成時間の短縮**: テスト作成時間を30分→5分に短縮
- **テストカバレッジの向上**: 標準的なテストケースを自動生成
- **テスト品質の統一**: 一貫したテスト構造の確保

#### 実装方針

テスト生成スクリプト

```typescript
// scripts/generate-test.ts
// 特性効果クラスからテストファイルを自動生成
// - 基底クラスに応じたテストテンプレートを選択
// - 設定ファイルのパラメータに基づいてテストケースを生成
```

生成されるテスト例

`BaseTypeAbsorbEffect`を継承するクラス用のテンプレート:

- `isImmuneToType`のテスト（無効化タイプの確認）
- `onAfterTakingDamage`のテスト（HP回復の確認）
- HP上限のテスト（最大HPを超えないことの確認）

テストテンプレートの種類

基底クラスごとに以下のテンプレートを用意する。

- `BaseTypeAbsorbEffect`: タイプ無効化テスト、HP回復テスト
- `BaseWeatherDependentSpeedEffect`: 天候条件テスト、速度倍率テスト
- `BaseStatusConditionEffect`: 状態異常付与確率テスト、免疫タイプテスト
- `BaseTypeImmunityEffect`: タイプ無効化テスト
- `BaseOpponentStatChangeEffect`: ステータス変化テスト
- `BaseConditionalDamageEffect`: 条件判定テスト、ダメージ修正テスト

### 9.3. 基底クラスの拡充

よく使われるパターンに対応する基底クラスを追加し、実装を簡素化する。

#### 目的

- **新規実装の簡素化**: 基底クラスを継承するだけで実装可能に
- **コード量の削減**: 重複コードの削減
- **保守性の向上**: 共通ロジックの一元管理

#### 追加すべき基底クラス

以下の基底クラスを優先的に追加する。

1. **BaseStatBoostEffect** - ステータス上昇系
   - 例: はりきり、かたやぶり
   - パラメータ: 上昇するステータス、上昇量

2. **BaseTypeBoostEffect** - タイプ一致時の威力上昇
   - 例: てきおうりょく、スナイパー
   - パラメータ: 対象タイプ、倍率

3. **BaseHpThresholdEffect** - HP閾値による効果
   - 例: こんじょう、しんりょく
   - パラメータ: HP閾値、発動条件、効果内容

4. **BaseWeatherDependentDamageEffect** - 天候依存のダメージ修正
   - 例: すなのちから（砂嵐時）
   - パラメータ: 天候条件、ダメージ倍率

5. **BaseMultiHitEffect** - 連続攻撃技用
   - 例: みだれひっかき、つつく
   - パラメータ: 攻撃回数、各攻撃の威力

6. **BaseRecoilEffect** - 反動ダメージ系
   - 例: すてみタックル、とっしん
   - パラメータ: 反動率

#### 実装優先順位

1. **Phase 1（即座に実装）**: よく使われるパターン
   - `BaseStatBoostEffect`
   - `BaseTypeBoostEffect`
   - `BaseHpThresholdEffect`

2. **Phase 2（短期）**: 中頻度のパターン
   - `BaseWeatherDependentDamageEffect`
   - `BaseMultiHitEffect`

3. **Phase 3（中期）**: 特殊なパターン
   - `BaseRecoilEffect`
   - その他の特殊効果

#### 基底クラス実装のガイドライン

- **抽象メソッドの最小化**: 必要なパラメータのみを抽象プロパティとして定義
- **デフォルト実装の提供**: 可能な限りデフォルト実装を提供
- **テストの自動生成対応**: 基底クラスごとにテストテンプレートを用意
- **ドキュメントの整備**: 各基底クラスの使用方法を明確に記載

### 9.4. レジストリの網羅性チェックとIssue生成

DBに存在する全ての特性・技がレジストリに登録されているかを確認し、未実装の特性・技をカテゴリ別にIssueとして生成するツールを整備する。

#### 目的

- **実装状況の可視化**: DBに存在する特性・技とレジストリの実装状況を可視化
- **網羅性の確保**: 全ての特性・技を漏れなく実装するための管理
- **Issue作成の効率化**: カテゴリ別のIssueを自動生成し、実装タスクを明確化

#### 実装内容

##### 網羅性チェックスクリプト

`server/src/scripts/check-registry-coverage.spec.ts` を実装。

- **機能**:
  - DBから全ての特性・技を取得
  - レジストリに登録済みの特性・技と比較
  - 未実装の特性・技をカテゴリ別・トリガー別に分類
  - 実装率を算出
  - CSV形式で詳細リストを出力

- **実行方法**: `npm run check:coverage`

- **出力内容**:
  - 総特性数・実装済み数・未実装数・実装率
  - カテゴリ別の未実装特性リスト
  - トリガー別の未実装特性リスト
  - カテゴリ別の未実装技リスト
  - CSV形式の詳細データ

##### Issue生成スクリプト

`server/src/scripts/generate-category-issues.ts` を実装。

- **機能**:
  - カテゴリ別に未実装の特性・技を集計
  - GitHub Issue作成用のフォーマットでIssue本文を自動生成
  - 各カテゴリの未実装特性・技を網羅的にリスト化（表形式）

- **実行方法**: `npm run generate:issues`

- **出力内容**:
  - カテゴリ別のIssueタイトルと本文
  - 各カテゴリの未実装特性・技の完全なリスト（表形式）
  - トリガー別の分類（特性の場合）
  - 実装手順と注意事項

#### 使用方法

1. **網羅性チェックの実行**

   ```bash
   npm run check:coverage
   ```

   - 現在の実装状況を確認
   - 未実装の特性・技を特定

2. **Issue生成の実行**

   ```bash
   npm run generate:issues
   ```

   - カテゴリ別のIssue本文を生成
   - 出力された内容をコピーしてGitHub Issueを作成

3. **Issue作成**
   - 生成されたIssue本文を使用してGitHub Issueを作成
   - 各カテゴリのIssueには、そのカテゴリに属する全ての未実装特性・技のリストが含まれる

#### 注意事項

- **網羅性の重要性**: 各カテゴリのIssueには、そのカテゴリに属する全ての未実装特性・技をリスト化する必要がある
- **実装完了後の確認**: 実装完了後は、再度`npm run check:coverage`を実行して網羅性を確認する
- **カテゴリ分類の更新**: `ability-mapping.ts`のマッピングが不足している場合、特性は全て`Other`カテゴリに分類される

## 10. リファクタリングの改善基準と方針

本システムは開発初期段階（完成度20%程度）であることを前提に、将来的に技術的負債となる因子を早期に特定し、段階的に改善するための基準と方針を定める。

### 10.1. 負債因子の分類と優先度

#### 緊急度：高（即座に対応）

1. **マジックナンバーの排除**
   - 確率値、ダメージ計算の係数、ステータス計算の係数、倍率、レベルやターン数の上限など、意味が不明確な数値が直接記述されていないか確認
   - 対応: クラスレベルの `private static readonly` 定数として定義し、意味が明確な名前を付ける
   - 対象例: `DamageCalculator`, `StatusConditionHandler`, `StatCalculator`

2. **console.logの削除**
   - 本番環境では不要なログを削除し、Nest.jsのLoggerサービスを使用
   - 対応: `console.log`を削除し、`Logger`サービスに置き換え

3. **エラーハンドリングの統一**
   - 汎用エラー（`throw new Error`）をカスタム例外クラスに置き換え
   - 対応: ドメイン層用の例外クラス（`DomainException`, `NotFoundException`, `ValidationException`, `InvalidStateException`）を作成し、Infrastructure層でHTTP例外に変換

#### 緊急度：中（短期対応）

4. **型安全性の向上**
   - テストファイルでの`as any`の使用を最小限に
   - 対応: テスト用のモック型を適切に定義し、型安全なモックを作成

5. **巨大クラスの分割**
   - 複数の責務を持つクラス（例: 945行の`ExecuteTurnUseCase`）を分割
   - 対応: 以下のサービスに分割
     - `ActionOrderDeterminer`: 行動順決定
     - `MoveExecutor`: 技実行
     - `PokemonSwitcher`: ポケモン交代
     - `StatusConditionProcessor`: 状態異常処理
     - `WinnerChecker`: 勝敗判定

6. **レジストリ初期化のエラーハンドリング**
   - レジストリ初期化失敗時の挙動を明確化
   - 対応: `onModuleInit`ライフサイクルフックを使用し、初期化失敗時はアプリケーション起動を停止

#### 緊急度：低（中長期対応）

7. **データ変換ロジックの共通化**
   - `toDomainEntity()`メソッドが各リポジトリに重複実装されている
   - 対応: 共通のMapperクラスを作成し、変換ロジックを一元管理

8. **バリデーションの強化**
   - 入力値のバリデーションが不十分な箇所を特定
   - 対応: DTOクラスにバリデーション装飾子を追加し、ドメイン層でのバリデーションロジックを強化

9. **テストカバレッジの向上**
   - 未カバーの重要なロジックにテストを追加
   - 対応: カバレッジレポートを確認し、エッジケースのテストを強化

### 10.2. 改善基準

#### コード品質基準

- **マジックナンバー**: すべての数値は定数として定義
- **関数の長さ**: 100行以下（巨大クラス分割後）
- **クラスの責務**: 単一責任の原則に従う
- **型安全性**: `any`型の使用を最小限に（テストを除く）

#### アーキテクチャ基準

- **依存関係**: クリーンアーキテクチャの原則を厳守
- **エラーハンドリング**: 統一された例外処理
- **ログ出力**: Loggerサービスを使用

#### テスト基準

- **カバレッジ**: ドメインロジックは80%以上
- **テスト品質**: エッジケースを含む
- **型安全性**: テストでも`as any`を避ける

### 10.3. 実装優先順位と段階的アプローチ

#### Phase 1: 基盤整備（1-2週間）

1. マジックナンバーの定数化
2. console.logの削除とLogger導入
3. カスタム例外クラスの作成

#### Phase 2: アーキテクチャ改善（2-3週間）

4. 巨大クラスの分割
5. レジストリ初期化の改善
6. 型安全性の向上

#### Phase 3: 品質向上（3-4週間）

7. データ変換ロジックの共通化
8. バリデーションの強化
9. テストカバレッジの向上

### 10.4. 実装時の注意事項

1. **段階的実装**: 一度にすべてを変更せず、小さな単位で実装
2. **テストの維持**: リファクタリング中も既存テストを維持
3. **コミット粒度**: 1コミット=1論理変更の原則を遵守
4. **ドキュメント更新**: 変更内容をREQUIREMENT.mdに反映

### 10.5. 成功指標

- マジックナンバーが0件になる
- 巨大クラス（例: ExecuteTurnUseCase）が300行以下になる
- `as any`の使用がテストファイルのみになる
- エラーハンドリングが統一される
- テストカバレッジが80%以上になる
