# ポケモンバトルシステム設計概要

本ドキュメントは、Nest.js、クリーンアーキテクチャ、および Prisma を使用して、スケーラブルなポケモンバトル環境を構築するためのシステム設計をまとめたものである。

## 1. 基本設計思想：データとロジックの分離

本システムの設計における最も重要な原則は、「データ（状態）」と「ロジック（振る舞い）」を厳密に分離することである。

- **データベース (DB) の役割**
  - 例: 「カイリューの特性は『マルチスケイル』である」という状態を永続化する。
  - ロジックそのもの（例: 「HP が満タンならダメージ半減」）は DB に保存しない。

- **アプリケーション (バトルエンジン) の役割**
  - DB から取得した「マルチスケイル」という名前（識別子）に基づき、ハードコードされたロジックを実行する。

## 2. 複雑なロジック（特性・技）の管理

特に「特性」のように複雑で将来的に拡張されうる（例: 1000 種類を超える）ロジックは、以下の設計アプローチを採用する。

### 2.1. マスターデータの役割 (Prisma / DB)

Ability や Move のマスターテーブルは、ロジックの「補助」に徹する。

- **name (String)**: アプリケーション側がロジックを識別するための一意なキー（例: `Intimidate`, `Levitate`）。
- **description (String)**: UI 表示用の説明文。
- **triggerEvent (String / Enum)**: ロジックの発動タイミングを示す補助フラグ（例: `OnEntry`, `OnTakingDamage`, `Passive`）。
- **effectCategory (String / Enum)**: 効果の大まかな分類（例: `StatChange`, `Immunity`, `Weather`）。

### 2.2. アプリケーション（バトルエンジン）のアーキテクチャ

switch 文による巨大な分岐処理は、保守性・拡張性の観点から採用しない。代わりに Strategy パターンとレジストリ（Registry）パターンを採用する。

- **インターフェース定義**: 特性ロジックの共通規格（例: `IAbilityEffect`）を定義する。これには `onEntry()`, `modifyDamage()`, `onTurnEnd()` といった、様々な発動タイミングに対応するメソッドシグネチャが含まれる。
- **ロジックの実装**: 特性ごとに、インターフェースを実装した個別のクラス（または関数）を作成する（例: `IntimidateEffect.ts`, `LevitateEffect.ts`）。
- **レジストリ（登録簿）**: DB の name（文字列キー）と、上記で実装したロジッククラスを紐付ける Map を作成する（例: `Map<string, IAbilityEffect>`）。
  - 例: `abilityRegistry.set('いかく', new IntimidateEffect())`
- **バトルエンジンの実行**: `triggerEvent` に基づいて処理を行う。巨大な switch 文の代わりに、DB から取得した特性の `name` をキーとしてレジストリを呼び出し、該当するロジックを実行する。

バトルエンジンの擬似コード（`onEntry` イベント）:

```ts
const abilityName = pokemon.ability.name; // DB から取得した名前
const event = pokemon.ability.triggerEvent; // DB から取得したトリガー

if (event === 'OnEntry') {
  // switch 文ではなく、Map からロジックを取得
  const effectLogic = abilityRegistry.get(abilityName);
  if (effectLogic) {
    effectLogic.onEntry(pokemon, battleContext);
  }
}
```

## 3. 技術スタックとアーキテクチャ

- **フレームワーク**: Nest.js
- **アーキテクチャ**: クリーンアーキテクチャ
- **ORM**: Prisma
- **リアルタイム通信**: WebSocket (Nest.js Gateway)

### 3.1. クリーンアーキテクチャのレイヤー構造

依存性のルール（内側は外側を知らない）を厳守する。

- **ドメイン (Entities)**
  - システムの中核。Nest.js や Prisma に依存しない純粋な TypeScript クラス。
  - 例: `Pokemon`, `Battle`, `BattlePokemonStatus` といったエンティティ、`DamageCalculator` などのドメインロジック。
  - `*.repository.interface.ts`（抽象リポジトリ）もここに定義する。

- **アプリケーション (Use Cases)**
  - ビジネスロジック。ドメイン層をオーケストレーション（指揮）する。
  - 例: `ExecuteTurnUseCase`（ターン処理）, `StartBattleUseCase`（バトル開始）。

- **インフラストラクチャ (Interface Adapters)**
  - 外界とアプリケーション層を接続する。
  - `*.controller.ts`: HTTP リクエストを処理し、ユースケースを呼び出す。
  - `*.gateway.ts`: WebSocket 通信を処理し、ユースケースを呼び出す。
  - `*.prisma.repository.ts`: ドメイン層で定義された `*.repository.interface.ts` の具象実装。Prisma Client をここで使用する。

- **フレームワーク (Frameworks & Drivers)**
  - Nest.js 自体、Prisma Client、PostgreSQL など。

### 3.2. ディレクトリ構造（抜粋）

`src/modules` 配下に、機能ドメインごとにモジュールを分割する。

```text
src/
├── modules/
│   ├── battle/           # バトル進行モジュール
│   │   ├── domain/
│   │   │   ├── entities/
│   │   │   ├── logic/      # DamageCalculator, AbilityRegistry など
│   │   │   └── battle.repository.interface.ts
│   │   ├── application/
│   │   │   └── use-cases/  # ExecuteTurnUseCase など
│   │   ├── infrastructure/
│   │   │   ├── persistence/  # battle.prisma.repository.ts
│   │   │   ├── battle.controller.ts
│   │   │   └── battle.gateway.ts
│   │   └── battle.module.ts
│   │
│   ├── pokemon/          # ポケモンマスターデータ管理モジュール
│   │   ├── domain/
│   │   │   ├── entities/   # Pokemon, Move, Ability
│   │   │   └── pokemon.repository.interface.ts
│   │   ├── application/
│   │   ├── infrastructure/
│   │   └── pokemon.module.ts
│   │
│   └── trainer/          # ユーザー・育成個体管理モジュール
│       ├── domain/
│       ├── application/
│       ├── infrastructure/
│       └── trainer.module.ts
│
└── shared/               # 共有リソース（PrismaModule など）
```

## 4. Prisma スキーマ設計のハイライト

`prisma/schema.prisma` は、以下の 3 つの主要カテゴリで構成される。

- **静的マスターデータ**
  - `Pokemon`, `Type`, `Move`, `Ability`, `Item`, `Nature`, `TypeEffectiveness`
  - これらはゲームのバージョンによって定義される不変のデータ。

- **ユーザーデータ（動的データ）**
  - `Trainer`: ユーザーアカウント。
  - `TrainedPokemon`: ユーザーが育成した個体（個体値、努力値、技構成など）。
  - `Team`: `TrainedPokemon` で構成されるバトルチーム。

- **バトルデータ（揮発性データ）**
  - `Battle`: バトル全体の状態（天候、ターン数、フィールド状態）。
  - `BattlePokemonStatus`: 最も重要。バトル中のポケモン個別の状態（現在の HP、状態異常、ランク補正）を管理する。`Battle` と `TrainedPokemon` に関連付けられる。

## 5. バトルルールの詳細仕様

本システムで実装されているバトルルールの詳細仕様を以下に記載する。

### 5.1. バトル基本ルール

- **ターン制**: 各トレーナーが行動を選択し、同時に実行される
- **行動順の決定**: 速度と優先度を考慮して決定
  - 優先度が高い技を先に実行
  - 優先度が同じ場合は、速度が高いポケモンが先に行動
  - 速度ランク補正を考慮
- **標準レベル**: レベル50を標準とする（ダメージ計算などで使用）

### 5.2. ダメージ計算の詳細

ダメージ計算は `DamageCalculator` クラスで実装されている。

#### 基本計算式

```
ダメージ = floor((floor((2 * level / 5 + 2) * power * A / D) / 50) + 2) * その他の補正
```

- `level`: ポケモンのレベル（標準: 50）
- `power`: 技の威力
- `A`: 攻撃側の実効ステータス（ランク補正適用後）
- `D`: 防御側の実効ステータス（ランク補正適用後）

#### 補正要素

1. **タイプ一致（STAB: Same Type Attack Bonus）**
   - 技のタイプとポケモンのタイプ（プライマリまたはセカンダリ）が一致する場合、1.5倍
   - 一致しない場合は1.0倍

2. **タイプ相性**
   - 効果値: 0（効果なし）、0.5（いまひとつ）、1.0（普通）、2.0（効果抜群）
   - 複数タイプのポケモンの場合、各タイプとの相性を掛け算
   - 例: ほのおタイプの技 → くさ・むしタイプのポケモン = 2.0 × 2.0 = 4.0倍

3. **ランク補正**
   - ランク範囲: -6から+6まで
   - 正のランク: 倍率 = (3 + rank) / 3
   - 負のランク: 倍率 = 3 / (3 - rank)
   - 例: ランク+1 = 4/3倍、ランク-1 = 3/4倍

4. **状態異常補正**
   - やけど（Burn）: 物理攻撃の威力が0.5倍
   - その他の状態異常はダメージ計算に直接影響しない（ターン終了時のダメージは別処理）

5. **天候補正**
   - 晴れ（Sun）:
     - ほのおタイプの技: 1.5倍
     - みずタイプの技: 0.5倍
   - 雨（Rain）:
     - みずタイプの技: 1.5倍
     - ほのおタイプの技: 0.5倍
   - 砂嵐（Sandstorm）・あられ（Hail）: 補正なし（1.0倍）

6. **特性効果による補正**
   - 攻撃側の特性: `modifyDamageDealt()` メソッドでダメージを修正
   - 防御側の特性: `modifyDamage()` メソッドで受けるダメージを修正
   - 例: マルチスケイル（HP満タン時、受けるダメージ半減）

### 5.3. 状態異常の仕様

状態異常の処理は `StatusConditionHandler` クラスで実装されている。

#### やけど（Burn）

- **物理攻撃補正**: 物理攻撃の威力が0.5倍
- **ターン終了時のダメージ**: 最大HPの1/16
- **交代時の解除**: 解除される

#### こおり（Freeze）

- **行動不能**: 行動不能になる
- **解除確率**: 各ターン開始時に20%の確率で解除
- **交代時の解除**: 解除される

#### どく（Poison）

- **ターン終了時のダメージ**: 最大HPの1/8
- **交代時の解除**: 解除される

#### もうどく（BadPoison）

- **ターン終了時のダメージ**: 最大HPの1/16から始まり、毎ターン増加（最大1/2）
  - ターン数に応じて: 1/16, 2/16, 3/16, ..., 8/16 (1/2)
- **交代時の解除**: 解除される

#### ねむり（Sleep）

- **行動不能**: 行動不能になる
- **自動解除**: 1-3ターン後に自動解除
  - 1ターン目: 33%の確率で解除
  - 2ターン目: 50%の確率で解除
  - 3ターン目以降: 100%の確率で解除
- **交代時の解除**: 解除される

#### まひ（Paralysis）

- **素早さ補正**: 素早さが0.5倍（速度ランク補正とは別）
- **行動不能確率**: 25%の確率で行動不能
- **交代時の解除**: 解除される

### 5.4. 命中率計算の仕様

命中率判定は `AccuracyCalculator` クラスで実装されている。

#### 基本命中率

- 技の基本命中率: 0-100（必中技の場合はnull）
- 必中技（accuracy === null）の場合は常に命中

#### ランク補正

- 命中ランク補正: 攻撃側の `accuracyRank` に基づく倍率
- 回避ランク補正: 防御側の `evasionRank` に基づく倍率
- 実効命中率 = 基本命中率 × (命中ランク倍率 / 回避ランク倍率)
- ランク補正の計算式はダメージ計算と同じ（正のランク: (3 + rank) / 3、負のランク: 3 / (3 - rank)）

#### 特性による補正

- 攻撃側の特性: `modifyAccuracy()` メソッドで命中率を修正
- 防御側の特性: `modifyEvasion()` メソッドで回避率を修正（0.0-1.0の値、大きいほど回避率が高い）

#### 最終判定

- 実効命中率を0-100の範囲に制限
- ランダムな値（0-100）を生成し、実効命中率未満なら命中

### 5.5. 特性・技の効果の仕様

#### 特性レジストリパターン

特性のロジックは `AbilityRegistry` クラスで管理される。

- **登録方法**: DBの `name` フィールドをキーとして、`IAbilityEffect` インターフェースを実装したクラスを登録
- **発動タイミング**: `triggerEvent` に基づいて処理
  - `OnEntry`: 場に出すとき
  - `OnTakingDamage`: ダメージを受けるとき
  - `OnDealingDamage`: ダメージを与えるとき
  - `OnTurnEnd`: ターン終了時
  - `OnSwitchOut`: 場から下がるとき
  - `Passive`: 常時発動（無効化されない限り）
  - `OnStatusCondition`: 状態異常になったとき
  - `Other`: その他

- **主要メソッド**:
  - `onEntry()`: 場に出たときの処理
  - `modifyDamage()`: 受けるダメージを修正
  - `modifyDamageDealt()`: 与えるダメージを修正
  - `modifyAccuracy()`: 命中率を修正
  - `modifyEvasion()`: 回避率を修正
  - `onTurnEnd()`: ターン終了時の処理

#### 技レジストリパターン

技の特殊効果ロジックは `MoveRegistry` クラスで管理される。

- **登録方法**: DBの `name` フィールドをキーとして、`IMoveEffect` インターフェースを実装したクラスを登録
- **主要メソッド**:
  - `onHit()`: 技が命中したときの処理（状態異常付与など）
  - `onUse()`: 技を使用したときの処理

- **注意**: 技の基本情報（威力、命中率、PPなど）はDBに保存されるが、特殊効果（例: 「10%の確率でやけどを付与する」）はアプリケーション側で管理

## 6. データ取得とアプリケーション層の依存関係

本システムでは、クリーンアーキテクチャの原則に従い、データ取得とアプリケーション層の依存関係を明確に分離している。

### 6.1. リポジトリパターンの実装

#### Domain層でのインターフェース定義

Domain層（`domain/*.repository.interface.ts`）で、データアクセスのインターフェースを定義する。

- 例: `IPokemonRepository`, `IAbilityRepository`, `IMoveRepository`, `IBattleRepository`
- これらのインターフェースは、Nest.jsやPrismaに依存しない純粋なTypeScriptインターフェース

#### Infrastructure層でのPrisma実装

Infrastructure層（`infrastructure/persistence/*.prisma.repository.ts`）で、上記インターフェースの具象実装を提供する。

- Prisma Clientを使用してDBからデータを取得
- Domain層のエンティティに変換して返す
- 依存性逆転の原則により、Domain層はInfrastructure層の実装を知らない

#### 依存性注入の設定

Nest.jsのモジュール（`*.module.ts`）で、インターフェースと具象実装をバインドする。

```typescript
{
  provide: POKEMON_REPOSITORY_TOKEN,
  useClass: PokemonPrismaRepository,
}
```

### 6.2. データフローの説明

#### 典型的なデータ取得フロー

1. **ユースケース層の呼び出し**
   - `ExecuteTurnUseCase` などのユースケースが、リポジトリインターフェースを呼び出す
   - 例: `await this.pokemonRepository.findById(id)`

2. **Infrastructure層でのデータ取得**
   - Prisma実装がDBからデータを取得
   - PrismaのデータモデルをDomain層のエンティティに変換

3. **Domain層でのロジック実行**
   - エンティティを取得後、ドメインロジック（`DamageCalculator`, `StatusConditionHandler`など）を実行

#### 特性・技ロジックの取得フロー

1. **DBから特性名を取得**
   - `TrainedPokemon` から `ability.name` を取得（例: "いかく"）

2. **レジストリからロジッククラスを取得**
   - `AbilityRegistry.get(abilityName)` でロジッククラスを取得
   - 例: `IntimidateEffect` インスタンス

3. **ロジックを実行**
   - 適切なメソッド（`onEntry()`, `modifyDamage()`など）を呼び出し
   - バトルコンテキスト（天候、フィールド状態など）を渡す

#### データ変換の責務

- **Prisma → Domain**: Infrastructure層の責務
  - Prismaのデータモデル（`Prisma.PokemonGetPayload<...>`）をDomain層のエンティティ（`Pokemon`）に変換
  - 例: `toDomainEntity()` メソッド

- **Domain → Prisma**: Infrastructure層の責務
  - Domain層のエンティティをPrismaのデータモデルに変換して保存
  - 例: `toPrismaInput()` メソッド

### 6.3. 依存関係の方向性

#### 依存性逆転の原則

- **Domain層**: 外部に依存しない（Nest.js、Prisma、PostgreSQLに依存しない）
- **Application層**: Domain層に依存（リポジトリインターフェースを使用）
- **Infrastructure層**: Domain層とApplication層に依存（インターフェースを実装）

#### レジストリパターンとの連携

- **レジストリの初期化**: モジュールのコンストラクタで実行
  - 例: `PokemonModule` のコンストラクタで `AbilityRegistry.initialize()` を呼び出し

- **レジストリへのアクセス**: Domain層のロジックから直接アクセス
  - 例: `DamageCalculator` から `AbilityRegistry.get()` を呼び出し

## 7. PokeAPIを使ったシードデータ作成の方針

本システムでは、マスターデータの初期投入のために、PokeAPIを利用したシードデータ作成を計画している。

### 7.1. シードデータの目的

- **マスターデータの初期投入**: Pokemon、Move、Ability、Type、TypeEffectivenessなどのマスターデータをDBに投入
- **開発・テスト環境での動作確認**: 開発やテスト時に、実際のポケモンデータを使用して動作確認を行う

### 7.2. PokeAPIの利用方針

#### API仕様

- **APIバージョン**: PokeAPI v2
- **APIドキュメント**: https://pokeapi.co/docs/v2
- **認証**: 不要（公開API）
- **レート制限**: 公式にはレート制限なし（ただし、ローカルキャッシュを推奨）

#### 取得するデータ

1. **Pokemon**
   - 図鑑番号（nationalDex）
   - 名前（name, nameEn）
   - タイプ（primaryType, secondaryType）
   - 基本ステータス（baseHp, baseAttack, baseDefense, baseSpecialAttack, baseSpecialDefense, baseSpeed）

2. **Move**
   - 名前（name, nameEn）
   - タイプ（typeId）
   - カテゴリ（category: Physical, Special, Status）
   - 威力（power）
   - 命中率（accuracy）
   - PP（pp）
   - 優先度（priority）
   - 説明（description）

3. **Ability**
   - 名前（name, nameEn）
   - 説明（description）
   - 発動タイミング（triggerEvent）
   - 効果カテゴリ（effectCategory）

4. **Type**
   - 名前（name, nameEn）

5. **TypeEffectiveness**
   - タイプ相性マトリクス（typeFromId, typeToId, effectiveness）

### 7.3. シードスクリプトの実装方針

#### ファイル構成

- **シードスクリプト**: `prisma/seed.ts` を作成
- **PokeAPIクライアント**: PokeAPIからデータを取得するためのユーティリティ関数

#### 実装の考慮事項

1. **エラーハンドリング**
   - APIリクエストの失敗時のリトライロジック
   - ネットワークエラーやタイムアウトの処理

2. **既存データのチェック**
   - 重複データの回避（`findUnique` などで既存データをチェック）
   - 既存データがある場合はスキップまたは更新

3. **データの整合性**
   - 外部キー制約の考慮（Type → Pokemon, Move, TypeEffectiveness）
   - トランザクション処理の実装

4. **パフォーマンス**
   - バッチ処理による効率的なデータ投入
   - 並列処理の検討（ただし、APIの負荷を考慮）

### 7.4. データマッピングの考慮事項

#### 名前の対応

- **PokeAPIのデータ**: 主に英語名（nameEn）が提供される
- **日本語名の取得**: PokeAPIの `names` フィールドから日本語名を取得
- **レジストリとの一致**: 特性・技の `name` フィールドとレジストリのキーを一致させる必要がある
  - 例: AbilityRegistryに `'いかく'` が登録されている場合、DBの `name` も `'いかく'` にする

#### タイプ相性データの変換

- **PokeAPIの形式**: `damage_relations` フィールドからタイプ相性を取得
- **DBの形式**: `TypeEffectiveness` テーブルに `typeFromId`, `typeToId`, `effectiveness` として保存
- **効果値の変換**: 
  - `no_damage_to` → effectiveness = 0
  - `half_damage_to` → effectiveness = 0.5
  - `double_damage_to` → effectiveness = 2.0
  - その他 → effectiveness = 1.0

#### 特性・技のメタデータ

- **triggerEvent**: PokeAPIから直接取得できない場合、特性名に基づいてマッピングテーブルを作成
- **effectCategory**: 同様に、特性名に基づいてマッピングテーブルを作成

### 7.5. 実装の優先順位

1. **Phase 1**: Type、Pokemon、Moveの基本データ投入
2. **Phase 2**: Ability、TypeEffectivenessのデータ投入
3. **Phase 3**: PokemonAbility、PokemonMoveの中間テーブルのデータ投入

### 7.6. 注意事項

- **PokeAPIのレート制限**: 公式にはレート制限なしとされているが、過度なリクエストは避ける
- **ローカルキャッシュ**: 取得したデータをローカルにキャッシュし、再実行時の高速化を図る
- **データの更新**: PokeAPIのデータが更新された場合の再投入方法を検討
- **エッジケース**: 一部のポケモンや技でデータが不完全な場合の処理

## 8. 開発プロセスと品質保証

セーフティネットとして、以下の開発ルールを設ける

### 8.1. ブランチ管理

- **mainブランチへの直接コミットは禁止**
  - 機能追加・修正・リファクタリングを行う場合は、必ず適切な名前のブランチを作成してから作業を開始
  - コミット前に現在のブランチを確認し、mainブランチの場合はブランチを作成してからコミット
  - ブランチ命名規則: `feat/`, `fix/`, `refactor/`, `chore/`, `docs/` のプレフィックスを使用

### 8.2. テストと動作確認

- **新規ロジックを追加した場合は、必ずテストケースを追加するか、動作確認を行うこと**
  - ドメインロジック（計算ロジック、バリデーションなど）はテストケースを追加し、テストを実行して成功することを確認
  - インフラストラクチャ層（API、WebSocketなど）は実際にアプリを起動して動作確認を行う
  - テストケースを追加した場合は、必ずテストを実行して成功することを確認してからコミット

### 8.3. コミット前チェック項目

コミット前に、以下の項目を**必ず**確認する。

- 現在のブランチがmainでないことを確認
- `npm run lint` がエラーなく通過すること
- `npm run build` が成功すること
- 新規ロジックを追加した場合、最低限のテストまたは動作確認を行ったこと
- Prismaスキーマを変更した場合、マイグレーションが必要な場合は準備したこと

### 8.4. コミットメッセージ規約

すべてのコミットメッセージは、Conventional Commits 形式に従う。

- `feat`: 新機能
- `fix`: バグ修正
- `refactor`: リファクタリング
- `docs`: ドキュメントのみの変更
- `test`: テストの追加・変更
- `chore`: ビルドプロセスやツールの変更
- `style`: コードの動作に影響しない変更（フォーマット、空白など）

### 8.5. セルフレビューの観点

コミット前に、以下の観点からコードをセルフレビューすることを必須とする。

#### マジックナンバー

確率値、ダメージ計算の係数、ステータス計算の係数、倍率、レベルやターン数の上限、最小値・最大値の制約など、意味が不明確な数値が直接記述されていないか確認する。

対応: クラスレベルの `private static readonly` 定数として定義し、意味が明確な名前を付ける。

#### エラーハンドリング

null/undefinedチェックが適切に行われているか、例外処理が適切か、エラーメッセージが明確か、エラーが適切に伝播されているかを確認する。

対応: null/undefinedチェックを追加し、適切な例外をthrowし、エラーメッセージを明確にする。

#### バリデーション

パラメータのバリデーションが適切か、境界値チェックが実装されているか、不正な値に対する処理が適切かを確認する。

対応: 入力値のバリデーションを追加し、境界値チェックを実装する。

#### パフォーマンス

不要なループや再帰がないか、適切なデータ構造を使用しているか、メモリリークの可能性がないか、不要なデータベースクエリがないかを確認する。

対応: アルゴリズムを最適化し、適切なデータ構造を選択し、メモリ管理を改善する。

#### メモリ管理

MapやSetなどのコレクションが適切にクリーンアップされているか、イベントリスナーの解除漏れがないか、タイマーやインターバルのクリーンアップが適切かを確認する。

対応: 不要になったリソースを適切に解放し、ライフサイクルに応じたクリーンアップ処理を追加する。

#### 型安全性

`any`型を使用していないか、型アサーションを過度に使用していないか、型定義が適切かを確認する。

対応: `any`型を避け、適切な型を定義し、型アサーションを最小限にする。

#### 重複コード

同じロジックが複数箇所に存在しないか、類似した処理が重複していないかを確認する。

対応: 共通処理を関数やメソッドに抽出し、ユーティリティクラスを作成する。

#### 関数・メソッドの責務

関数が複数の責務を持っていないか、関数が長すぎないか（100行以上など）、複雑度が高くないかを確認する。

対応: 関数を小さな単位に分割し、責務を明確に分離する。

#### 可読性

変数名が明確か、ネストが深すぎないか、条件式が複雑すぎないかを確認する。

対応: 意味が明確な変数名・関数名を使用し、ネストを浅くし、条件式を簡潔にする。

#### ロジックの正確性

計算式が正しいか、条件分岐が適切か、エッジケースを考慮しているかを確認する。

対応: ロジックを再確認し、エッジケースを考慮し、テストケースで検証する。

#### コメント

変数名やメソッド名だけでは意図が伝わらない箇所にコメントがあるか、複雑な計算式やロジックの説明が適切か、データ構造のキーの意味が明確かを確認する。

対応: コメントで意図を明確に説明し、データ構造のキーの意味を明記する。

#### コードスタイル

フォーマットが統一されているか、命名規則が統一されているか、インポート順序が統一されているかを確認する。

対応: ESLint/Prettierの設定に従い、既存のコードスタイルに合わせる。

#### 設計思想の遵守

クリーンアーキテクチャの原則に反していないか、データとロジックの分離原則に反していないか、依存性の方向が適切かを確認する。

対応: REQUIREMENT.mdの設計思想を確認し、必要に応じて設計を修正する。

#### テスト

ドメインロジックにテストケースがあるか、エッジケースがテストされているか、テストカバレッジが適切かを確認する。

対応: テストケースを追加し、テストを実行して成功することを確認する。

#### セキュリティ

SQLインジェクションの可能性がないか、XSSの可能性がないか、認証・認可が適切に実装されているかを確認する。

対応: セキュリティベストプラクティスに従い、適切なサニタイゼーションを実装する。

#### 並行処理

レースコンディションの可能性がないか、デッドロックの可能性がないか、スレッドセーフティが確保されているかを確認する。

対応: 適切な同期機構を使用し、レースコンディションを回避する。
